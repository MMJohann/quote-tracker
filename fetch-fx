#!/usr/bin/python

import httplib
import json
import datetime
import time
import sys

debug = 0

if not debug:
    from google.appengine.api import memcache
    from google.appengine.api import mail
    from google.appengine.api import xmpp

def xmpp_msg (msg):
    xmpp.send_message ("lapan_mv@jabber.ru", msg, None, xmpp.MESSAGE_TYPE_NORMAL)

# handler of new bar (send message to jabber)
def new_bar_message (period, pair1, pair2, ts, o, h, l, c):
    v = 'New %s bar on %s/%s: @%s O=>%f, H=>%f, L=>%f, C=>%f' % (period, pair1, pair2, ts_to_string (ts), o, h, l, c)
    xmpp_msg (v)
    print v

# fetch url of fx-experts application
def new_bar (period, pair1, pair2, ts, o, h, l, c):
    srv = "fx-experts.appspot.com"
    req = "/new_bar?pair1=%s&pair2=%s&period=%s&ts=%d&o=%f&h=%f&l=%f&c=%f" % (pair1, pair2, period, ts, o, h, l, c)
    conn = httplib.HTTPConnection (srv)
    print "Request: http://%s%s" % (srv, req)
    conn.request ("GET", do_req)
    r = conn.getresponse ()
    reply = r.read ()

def ts_to_string (ts):
    return "%s (%s UTC)" % (ts, datetime.datetime.utcfromtimestamp (ts).__str__ ())

# Available pairs:
# Primary: EUR/USD, AUD/USD, USD/CAD, USD/JPY, GBP/USD, USD/CHF, NZD/USD, USD/UKD, USD/SGD, USD/ZAR, USD/MXN
# Crosses: EUR/CHF, EUR/GBP, EUR/JPY, GBP/JPY, EUR/CAD, EUR/AUD, GBP/CHF, CHF/JPY, AUD/CAD, AUD/JPY, CAD/JPY, GBP/AUD, AUD/NZD, ZAR/JPY, 

pairs = [('EUR', 'USD')]

# Available periods table:
# M1 = 0
# M5 = 1
# M10 = 2
# M15 = 3
# M30 = 4
# H1 = 5
# H2 = 6
# H4 = 7
# D1 = 8
# W1 = 9
# M1 = 10

#periods = {'H1': 5, 'D1': 8}
periods = {
    'H1': {'arg': 5, 'interval': 3600},
    'D1': {'arg': 8, 'interval': 86400},
    }

server = "webcharts.fxserver.com"
req = "/charts/activeChartFeed.php?pair=%(pair1)s/%(pair2)s&period=%(period)d&unit=&limit=3&timeout=0&rateType=bid&GMT=off"

conn = httplib.HTTPConnection (server)

print 'Content-type: text/plain'
print

new_bars = []

for pair in pairs:
    pair1, pair2 = pair
    for per_name, per_data in periods.iteritems ():
        # memcache key of last timestamp
        key = "%s-%s-%s" % (pair1, pair2, per_name)
        print 'Check: %s-%s, %s' % (pair1, pair2, per_name)

        per_arg = per_data['arg']
        per_int = per_data['interval']

        print 'Current TS: %s' % ts_to_string (time.time ())

        # obtain timestamp of last bar
        if not debug:
            ts = memcache.get (key)
        if ts == None:
            print 'TS not found in memcache'
            ts = 0
        else:
            print 'We have memcached ts: %s' % ts_to_string (ts)
        if time.time () - ts < per_int:
            print '%s-%s, %s skipped' % (pair1, pair2, per_name)
            continue

        # perform server's request
        try:
            do_req = req % { 'pair1': pair1, 'pair2': pair2, 'period': per_arg }
            conn.request ("GET", do_req)
            r = conn.getresponse ()
            if r.status == 200:
                data = json.read (r.read ())['candles']
                print 'We got from srv: ', data
                # last complete bar value
                ts1 = data['time'][1]
                print 'Last complete bar: %s' % ts_to_string (ts1)
                if ts1 > ts:
                    # queue new bars for processing
                    new_bars += [(per_name, pair1, pair2, ts1, float (data['data'][1]['O']), float (data['data'][1]['H']),
                                  float (data['data'][1]['L']), float (data['data'][1]['C']))]
                else:
                    print 'We processed this bar already'
                # save timestamp
                if not debug:
                    memcache.set (key, ts1)
        except:
            xmpp_msg ("Global error: %s" % sys.exc_info ()[1])
            print 'Download error, skip it:', sys.exc_info ()

for bar in new_bars:
    # new bar, process it
    new_bar (bar[0], bar[1], bar[2], bar[3], bar[4], bars[5], bars[6], bars[7])
